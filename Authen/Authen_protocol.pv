type skey.
type pkey.
type signature.

(* Hàm về mã hóa*)
fun pk(skey): pkey.
fun sign(bitstring, skey): signature.
reduc forall m: bitstring, k: skey; verifysign(sign(m, k), pk(k)) = m.
fun aenc(bitstring, pkey ) : bitstring.
reduc forall m: bitstring , k : skey ; adec(aenc(m, pk(k)), k) = m.

(* Hàm về credential, đang thiếu kiểm tra pk(k) chính là public key của issuer *)
type credential.
fun make_credential(bitstring, bitstring, bitstring, signature): credential.
reduc
  forall issuer: bitstring, subject: bitstring, data: bitstring, k: skey;
    get_issuer_credential(make_credential(issuer, subject, data, sign((issuer, subject, data), k)), pk(k)) = issuer.
reduc
  forall issuer: bitstring, subject: bitstring, data: bitstring, k: skey;
    get_subject_credential(make_credential(issuer, subject, data, sign((issuer, subject, data), k)), pk(k)) = subject.

(* Hàm về presentation, đang thiếu kiểm tra pk(k) chính là public key của subject, và subject phải bằng subject trong vc, và issuer trong vc phải là bank *)
type presentation.
fun make_presentation(bitstring, bitstring, credential, signature): presentation.
reduc
  forall subject: bitstring, nonce: bitstring, vc: credential, k: skey;
    get_subject_presentation(make_presentation(subject, nonce, vc, sign((subject, nonce, vc), k)), pk(k)) = subject.
reduc
  forall subject: bitstring, nonce: bitstring, vc: credential, k: skey;
    get_nonce_presentation(make_presentation(subject, nonce, vc, sign((subject, nonce, vc), k)), pk(k)) = nonce.
reduc
  forall subject: bitstring, nonce: bitstring, vc: credential, k: skey;
    get_vc_presentation(make_presentation(subject, nonce, vc, sign((subject, nonce, vc), k)), pk(k)) = vc.

fun to_string(presentation) : bitstring  [typeConverter].
reduc forall vp: presentation, t: bitstring; to_presentation(to_string(vp)) = vp.

free didU: bitstring.
free didB: bitstring.
free skU: skey [private].
free skB: skey [private].
free data: bitstring [private].    (* Dữ liệu trong VC (ví dụ thông tin người dùng) *)

(* Kênh truyền thông công khai mà attacker có thể nghe/chặn (Dolev-Yao) *)
free c_auth: channel.
free c_resolve: channel.  (* [private] /resolve DID *)

(* Sự kiện đánh dấu các bước quan trọng để kiểm chứng *)
event userStart(bitstring, bitstring).    (* User bắt đầu xác thực với DID *)
event tokenIssued(bitstring, bitstring).  (* Bank phát hành token cho DID *)

let DIDResolver =
  in(c_resolve, did: bitstring);
  if did = didU then
    out(c_resolve, pk(skU))
  else if did = didB then
    out(c_resolve, pk(skB))
  else
    0.

(* Tiến trình của User: khởi xướng và thực hiện đăng nhập *)
let UserProcess = 
    out(c_resolve, didB);
    in(c_resolve, pkB: pkey);
    (* Ví dụ Verifiable Credential do Bank cấp cho User trước đó *)
    let vc_data = (didB, didU, data) in
    let sigVC = sign(vc_data, skB) in
    let cred = make_credential(didB, didU, data, sigVC) in
    (* Kiểm tra public key của bank *)
    let (=didB) = get_issuer_credential(cred, pkB) in
    let pkU = pk(skU) in
    (* Gửi yêu cầu đăng nhập *)
    out(c_auth, aenc((didU, pkU), pkB));
    (* Nhận nonce được mã hóa từ Bank *)
    in(c_auth, ResB: bitstring);
    (* Kiểm tra phản hồi từ Bank trên nonceU *)
    let (=didU, nonceB: bitstring) = adec(ResB, skU) in    
    (* Đánh dấu sự kiện User bắt đầu quá trình xác thực cho didU *)
    event userStart(didU, nonceB);
    (* Bước 3: Tạo VP gồm (nonce, didU, VC, chữ ký của User) *)
    let vp_data = (didU,nonceB, cred) in
    let sigVP = sign(vp_data, skU) in
    let prest = make_presentation(didU, nonceB, cred, sigVP) in
    out(c_auth, aenc(to_string(prest), pkB));
    (* Bước 4: Nhận accessToken từ Bank *)
    in(c_auth, token_enc: bitstring).

(* Tiến trình của Bank: chờ yêu cầu và đáp ứng *)
let BankProcess =
    in(c_auth, authenReq: bitstring);
    let (uDid:bitstring, pkU: pkey) = adec(authenReq, skB) in
    (* Bank nhận yêu cầu: uDid là DID từ User *)
    new nonceB: bitstring;
    (* Gửi nonce đã mã hóa *)
    out(c_auth, aenc((uDid, nonceB), pkU));
    (* Nhận VP từ User *)
    in(c_auth, prest_Res_enc: bitstring);
    (* Kiểm tra điều kiện an ninh trên VP *)
    let prest_Res = to_presentation(adec(prest_Res_enc, skB)) in
    let (=uDid) = get_subject_presentation(prest_Res, pkU) in
    let (=nonceB) = get_nonce_presentation(prest_Res, pkU) in
    let vc_res = get_vc_presentation(prest_Res, pkU) in
    let pkB = pk(skB) in
    let (=didB) = get_issuer_credential(vc_res, pkB) in
    let (=uDid) = get_subject_credential(vc_res, pkB) in
    (* Tạo accessToken mới và gửi cho User *)
    new token: bitstring;
    out(c_auth, aenc(token, pkU));
    (* Đánh dấu sự kiện Bank phát hành token cho DID tương ứng *)
    event tokenIssued(uDid, nonceB).

query did:bitstring, n1: bitstring;
  inj-event(tokenIssued(did, n1)) ==>
  inj-event(userStart(did, n1)).

query attacker(skU).
query attacker(skB).
query n1: bitstring; event(tokenIssued(didU, n1)).

(*query n: bitstring; event(userStart(didU, n)).
query n: bitstring; event(tokenIssued(didU, n)).
*)

process !UserProcess | !BankProcess | !DIDResolver

(*
Cải tiến:
- Có thể public VC được không
- Trường hợp khóa authen khác khóa VC (hiện tại = nhau)
- Trường hợp đã cải tiến: pkU gửi trực tiếp trong AuthenReq
 *)