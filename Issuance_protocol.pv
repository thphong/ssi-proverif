type skey.       (* secret signing key *)
type pkey.       (* public verification key *)

free didU: bitstring.   (* User DID *)
free didB: bitstring.   (* Bank DID *)

fun publickey(skey): pkey.
fun sign(bitstring, skey): bitstring.
fun checksign(bitstring, pkey): bitstring.

(* Correctness of signatures *)
equation forall m: bitstring, k: skey;
  checksign(sign(m, k), publickey(k)) = m.

(* ===== Secret Keys (kept private) ===== *)
free skU: skey [private].   (* User private key *)
free skB: skey [private].   (* Bank private key *)

(* ===== Communication Channels ===== *)
free c_n: channel.        (* /nonce *)
free c_c: channel.        (* /credential *)
free c_r: channel.  (* [private] /resolve DID *)

(* ===== Events ===== *)
event SentCredentialRequest(bitstring, bitstring).   (* (UserDID, nonce) *)
event IssuedCredential(bitstring, bitstring).        (* (UserDID, nonce) *)
event ResolvedDID(bitstring, pkey).                 (* (did, pk returned) *)

(* ===== Tables ===== *)
table registry(bitstring, pkey).
table usedNonce(bitstring, bitstring).

(* Registrar: only trusted process that populates registry *)
let Registrar =
  (* only run once: insert the true mappings *)
  insert registry(didU, publickey(skU));
  insert registry(didB, publickey(skB));
  0.

(* ===================================================== *)
(* DIDResolver: nhận DID → trả public key tương ứng      *)
(*  - Tra trong bảng registry                            *)
(*  - Nếu không có thì kết thúc                          *)
(* ===================================================== *)
let DIDResolver =
  in(c_r, did: bitstring);
  get registry(did, pk: pkey) in
    event ResolvedDID(did, pk);
    out(c_r, pk)
  else
    0.

(* ===================================================== *)
(* User Process                                          *)
(* ===================================================== *)
let User =

  (* Step 1: Request nonce from bank *)
  out(c_n, didU);
  in(c_n, (n: bitstring, didRecv: bitstring, sigB: bitstring));

  (* Resolve Bank public key từ DIDResolver *)
  out(c_r, didB);
  in(c_r, pkBank: pkey);

  (* Verify bank's signature on (n, didU) *)
  let mB = checksign(sigB, pkBank) in
  let (=n, =didU) = mB in

  (* Step 2: User ký (n, didU) bằng khóa bí mật của mình *)
  let sigU = sign((n, didU), skU) in
  event SentCredentialRequest(didU, n);
  out(c_c, (n, didU, sigU));

  (* Step 4: Receive credential code *)
  in(c_c, credential: bitstring).

(* ===================================================== *)
(* Bank Process                                          *)
(* ===================================================== *)
let Bank =

  (* Step 1: Receive DID and respond with nonce + signature *)
  in(c_n, didReq: bitstring);
  new nonce: bitstring;
  let sigB = sign((nonce, didReq), skB) in
  out(c_n, (nonce, didReq, sigB));

  (* Step 3: Receive signed credential request from user *)
  in(c_c, (n2: bitstring, did2: bitstring, sigU: bitstring));

  (* So sánh trước xem DID và nonce có khớp với yêu cầu ban đầu không *)
  if n2 = nonce && did2 = didReq then
    (* Resolve User public key từ DIDResolver *)
    out(c_r, did2);
    in(c_r, pkUer: pkey);

    (* Verify user's signature *)
    let mU = checksign(sigU, pkUer) in
    let (=nonce, =didReq) = mU in

    (* Kiểm tra chống replay *)
    get usedNonce(did2, n2) in
      0
    else
      insert usedNonce(did2, n2);
      event IssuedCredential(did2, n2);
      new credential: bitstring;
      out(c_c, credential)
  else
    0.

(* ===================================================== *)
(* Security Queries                                      *)
(* ===================================================== *)
query attacker(skU).
query attacker(skB).

(* Authentication: nếu bank đã cấp credential thì phải có request hợp lệ từ user *)
query n: bitstring;
  inj-event(IssuedCredential(didU, n)) ==>
  inj-event(SentCredentialRequest(didU, n)).

(* ensure resolver returned genuine key when issuing to didU 
query n: bitstring;
  inj-event(IssuedCredential(didU, n)) ==>
  inj-event(ResolvedDID(didU, publickey(skU))).*)

(* ===================================================== *)
(* Main Process                                          *)
(* ===================================================== *)
noselect k: skey, n: bitstring; attacker(sign((n, didU), k)).
process
   Registrar | (!User) | (!Bank) | (!DIDResolver)
